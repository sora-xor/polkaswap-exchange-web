var p=Object.defineProperty;var w=(a,e,t)=>e in a?p(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var u=(a,e,t)=>w(a,typeof e!="symbol"?e+"":e,t);import{h as l,V as b,o as c,b as m,hf as y,X as f,C as g}from"./index-BHqySXo4.js";var S=Object.defineProperty,A=Object.getOwnPropertyDescriptor,n=(a,e,t,r)=>{for(var s=r>1?void 0:r?A(e,t):e,i=a.length-1,o;i>=0;i--)(o=a[i])&&(s=(r?o(e,t,s):o(s))||s);return r&&s&&S(e,t,s),s};const V=7;let d=class extends b{constructor(){super(...arguments);u(this,"whitelist");u(this,"whitelistIdsBySymbol");u(this,"assetsDataTable");u(this,"wasRedirected",!1)}getRouteAddress(e){return e&&(e.length>V?this.assetsDataTable[e]?e:"":this.whitelistIdsBySymbol[e.toUpperCase()]??"")}getIsValidRoute(e,t,r,s){if(!(e||t))return!0;if(e===t||r===s)return!1;const i=!!(r&&s);switch(this.$route.name){case c.OrderBook:return i&&s===f.address;case c.AddLiquidity:return!(!(i&&m.api.dex.baseAssetsIds.includes(r))||r===y.address&&s===f.address);default:return i}}async setData(e){console.warn("[SelectedTokensRouteMixin]: setData was not set")}get firstRouteAddress(){return this.getRouteAddress(this.$route.params.first)}get secondRouteAddress(){return this.getRouteAddress(this.$route.params.second)}get isValidRoute(){const{first:e,second:t}=this.$route.params,r=this.firstRouteAddress,s=this.secondRouteAddress;return this.getIsValidRoute(e,t,r,s)}parseCurrentRoute(e){const t=e?e.isValidRoute:this.isValidRoute,r=e?e.name:this.$route.name;return t?!0:(this.wasRedirected=!0,this.$route.params&&this.$router.replace({name:r,params:void 0}),!1)}updateRouteAfterSelectTokens(e,t){if(!(e&&t))return;const r=this.whitelist[e.address]?e.symbol:e.address,s=this.whitelist[t.address]?t.symbol:t.address;this.$route.params.first===r&&this.$route.params.second===s||(this.wasRedirected=!0,this.$router.replace({name:this.$route.name,params:{first:r,second:s}}))}beforeRouteUpdate(e,t,r){if(this.wasRedirected)this.wasRedirected=!1;else{const s=e.params.first,i=e.params.second,o=this.getRouteAddress(s),h=this.getRouteAddress(i),R=this.getIsValidRoute(s,i,o,h);if(!this.parseCurrentRoute({isValidRoute:R,name:e.name}))return;this.setData({firstAddress:o,secondAddress:h})}r()}};n([l.wallet.account.whitelist],d.prototype,"whitelist",2);n([l.wallet.account.whitelistIdsBySymbol],d.prototype,"whitelistIdsBySymbol",2);n([l.wallet.account.assetsDataTable],d.prototype,"assetsDataTable",2);d=n([g],d);export{d as S};
